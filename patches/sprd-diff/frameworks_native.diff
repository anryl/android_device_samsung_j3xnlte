diff --git a/include/gui/ISurfaceComposerClient.h b/include/gui/ISurfaceComposerClient.h
index 3641fc1..2b4f584 100644
--- a/include/gui/ISurfaceComposerClient.h
+++ b/include/gui/ISurfaceComposerClient.h
@@ -52,6 +52,7 @@ public:
         eFXSurfaceNormal    = 0x00000000,
         eFXSurfaceBlur      = 0x00010000,
         eFXSurfaceDim       = 0x00020000,
+	eFXSurfaceHWAcc     = 0x00100000,
         eFXSurfaceMask      = 0x000F0000,
     };
 
diff --git a/include/media/openmax/OMX_Audio.h b/include/media/openmax/OMX_Audio.h
index d8bee76..e2ca139 100644
--- a/include/media/openmax/OMX_Audio.h
+++ b/include/media/openmax/OMX_Audio.h
@@ -108,6 +108,7 @@ typedef enum OMX_AUDIO_CODINGTYPE {
     OMX_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
     OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingIMAADPCM,    /**< Any variant of IMAADPCM encoded data */
     OMX_AUDIO_CodingMax = 0x7FFFFFFF
 } OMX_AUDIO_CODINGTYPE;
 
@@ -469,6 +470,20 @@ typedef struct OMX_AUDIO_PARAM_ADPCMTYPE {
                                     variable or unknown sampling rate. */
 } OMX_AUDIO_PARAM_ADPCMTYPE;
 
+/** IMAADPCM stream format parameters */
+typedef struct OMX_AUDIO_PARAM_IMAADPCMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlockAlign;        /**< Sampling rate of the source data.	Use 0 for
+                                    variable or unknown sampling rate. */
+} OMX_AUDIO_PARAM_IMAADPCMTYPE;
 
 /** G723 rate */
 typedef enum OMX_AUDIO_G723RATE {
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index f9b6f4b..4934a2e 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -170,6 +170,7 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m = 0x7FA30C04,
+    OMX_SPRD_COLOR_FormatYVU420SemiPlanar = 0x7FD00001,
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
diff --git a/include/media/openmax/OMX_Index.h b/include/media/openmax/OMX_Index.h
index 1a2a548..b3ba3c7 100644
--- a/include/media/openmax/OMX_Index.h
+++ b/include/media/openmax/OMX_Index.h
@@ -194,7 +194,7 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
     OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
     OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
-
+    OMX_IndexConfigEncSceneMode,
     /* Image & Video common Configurations */
     OMX_IndexCommonStartUnused = 0x07000000,
     OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
@@ -262,6 +262,7 @@ typedef enum OMX_INDEXTYPE {
        private indexes are not guaranteed unique and therefore should
        only be sent to the appropriate component. */
 
+    OMX_IndexParamAudioImaAdpcm = 0x7FA7B09C,/**< reference: OMX_AUDIO_PARAM_IMAADPCMTYPE */
     OMX_IndexMax = 0x7FFFFFFF
 
 } OMX_INDEXTYPE;
diff --git a/include/media/openmax/OMX_Video.h b/include/media/openmax/OMX_Video.h
index 76efac9..479c20b 100644
--- a/include/media/openmax/OMX_Video.h
+++ b/include/media/openmax/OMX_Video.h
@@ -961,6 +961,23 @@ typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
 } OMX_VIDEO_CONFIG_BITRATETYPE;
 
 /**
+ * Defines Encoder Scene Mode setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  nMode : Encoding scene mode(1:Volte, 2:Wfd, 0:Normal)
+ */
+
+typedef struct OMX_VIDEO_CONFIG_ENCODERSCENEMODE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMode;
+} OMX_VIDEO_CONFIG_ENCODERSCENEMODE;
+
+/**
  * Defines Encoder Frame Rate setting
  *
  * STRUCT MEMBERS:
diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index 3e127a1..0b20f68 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -68,6 +68,7 @@ public:
         USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK,
 
         USAGE_CURSOR            = GRALLOC_USAGE_CURSOR,
+	USAGE_HW_TILE_ALIGN     = GRALLOC_USAGE_HW_TILE_ALIGN,
     };
 
     GraphicBuffer();
diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index 3efebf7..ca02393 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -1136,6 +1136,12 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
         mProcess->spawnPooledThread(false);
         break;
 
+    // SPRD: Sometimes, doing binder operation in destructor could reveiving BR_TRANSACTION_COMPLETE here.
+    //       We handle this command simply and avoid crash.
+    case BR_TRANSACTION_COMPLETE:
+        ALOGE("*** BAD COMMAND: BR_TRANSACTION_COMPLETE(%x) for executeCommand from Binder driver\n", cmd);
+        break;
+
     default:
         printf("*** BAD COMMAND %d received from Binder driver\n", cmd);
         result = UNKNOWN_ERROR;
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 18cc946..e4b90c3 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -134,6 +134,10 @@ else
     LOCAL_CFLAGS += -DMAX_VIRTUAL_DISPLAY_DIMENSION=0
 endif
 
+ifeq ($(strip $(TARGET_GPU_NOT_SUPPORT_NV12_OUTPUT)),true)
+    LOCAL_CFLAGS += -DGPU_NOT_SUPPORT_NV12_OUTPUT
+endif
+
 ifeq ($(BOARD_USE_BGRA_8888),true)
     LOCAL_CFLAGS += -DUSE_BGRA_8888
 endif
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index 92c5e12..90c697f 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -121,7 +121,33 @@ DisplayDevice::DisplayDevice(
         config = RenderEngine::chooseEglConfig(display, format);
 #endif
     }
-    eglSurface = eglCreateWindowSurface(display, config, window, NULL);
+    
+    /*
+     *  Sprd change here:
+     *  Enable EGL NV12 config for GPU output NV12 image, for
+     *  VirtualDisplay.
+     * */
+#ifndef GPU_NOT_SUPPORT_NV12_OUTPUT
+    if (mType >= DisplayDevice::DISPLAY_VIRTUAL)
+    {
+        EGLConfig nv12Config;
+        EGLint numConfigs = 0;
+        static EGLint sDefaultConfigAttribs[] = {
+            EGL_CONFIG_ID, 43, EGL_NONE };
+        eglChooseConfig(display, sDefaultConfigAttribs, &nv12Config, 1, &numConfigs);
+        eglSurface = eglCreateWindowSurface(display, nv12Config, window, NULL);
+
+        /*
+         * Sync Framebuffer format to VirtualDisplay Surface.
+         * */
+        format = mDisplaySurface->getFBFormat();
+        native_window_set_buffers_format(window, format);
+    }
+    else
+#endif
+    {
+        eglSurface = eglCreateWindowSurface(display, config, window, NULL);
+    }
     eglQuerySurface(display, eglSurface, EGL_WIDTH,  &mDisplayWidth);
     eglQuerySurface(display, eglSurface, EGL_HEIGHT, &mDisplayHeight);
 
@@ -173,7 +199,7 @@ DisplayDevice::DisplayDevice(
     mPanelMountFlip = atoi(property);
 
     // initialize the display orientation transform.
-    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+    setDisplayDevice();
 
 #ifdef NUM_FRAMEBUFFER_SURFACE_BUFFERS
     surface->allocateBuffers();
@@ -371,11 +397,65 @@ EGLBoolean DisplayDevice::makeCurrent(EGLDisplay dpy, EGLContext ctx) const {
 void DisplayDevice::setViewportAndProjection() const {
     size_t w = mDisplayWidth;
     size_t h = mDisplayHeight;
+    char property[PROPERTY_VALUE_MAX];
+    if ((mType == DisplayDevice::DISPLAY_PRIMARY)
+        && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+        //displayOrientation
+        switch (atoi(property)) {
+            case 90:
+            case 270:
+            w = mDisplayHeight;
+            h = mDisplayWidth;
+            break;
+            default:
+            break;
+        }
+    }
     Rect sourceCrop(0, 0, w, h);
     mFlinger->getRenderEngine().setViewportAndProjection(w, h, sourceCrop, h,
         false, Transform::ROT_0);
 }
 
+void DisplayDevice::setDisplayDevice()
+{
+	// initialize the display orientation transform.
+	// it's a constant that should come from the display driver.
+	int displayOrientation = DisplayState::eOrientationDefault;
+	char property[PROPERTY_VALUE_MAX];
+	if ((mType == DisplayDevice::DISPLAY_PRIMARY)
+           && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+		//displayOrientation
+		switch (atoi(property)) {
+			case 90:
+			displayOrientation = DisplayState::eOrientation90;
+			break;
+
+			case 180:
+			displayOrientation = DisplayState::eOrientation180;
+			break;
+
+			case 270:
+			displayOrientation = DisplayState::eOrientation270;
+			break;
+		}
+	}
+
+	const int w = mDisplayWidth;
+	const int h = mDisplayHeight;
+	DisplayDevice::orientationToTransfrom(displayOrientation, w, h,
+	&mDisplayTransform);
+	if (displayOrientation & DisplayState::eOrientationSwapMask) {
+		mDisplayWidth = h;
+		mDisplayHeight = w;
+	} else {
+		mDisplayWidth = w;
+		mDisplayHeight = h;
+	}
+
+	// initialize the display orientation transform.
+	setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+}
+
 const sp<Fence>& DisplayDevice::getClientTargetAcquireFence() const {
     return mDisplaySurface->getClientTargetAcquireFence();
 }
@@ -576,7 +656,8 @@ void DisplayDevice::setProjection(int orientation,
     // The viewport and frame are both in the logical orientation.
     // Apply the logical translation, scale to physical size, apply the
     // physical translation and finally rotate to the physical orientation.
-    mGlobalTransform = R * TP * S * TL;
+    mGlobalTransform = mDisplayTransform * R * TP * S * TL;
+    mOriginalTransform = R * TP * S * TL;
 
     const uint8_t type = mGlobalTransform.getType();
     mNeedsFiltering = (!mGlobalTransform.preserveRects() ||
diff --git a/services/surfaceflinger/DisplayDevice.cpp.orig b/services/surfaceflinger/DisplayDevice.cpp.orig
new file mode 100644
index 0000000..92c5e12
--- /dev/null
+++ b/services/surfaceflinger/DisplayDevice.cpp.orig
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// #define LOG_NDEBUG 0
+#undef LOG_TAG
+#define LOG_TAG "DisplayDevice"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include <cutils/properties.h>
+
+#include <utils/RefBase.h>
+#include <utils/Log.h>
+
+#include <ui/DisplayInfo.h>
+#include <ui/PixelFormat.h>
+
+#include <gui/Surface.h>
+
+#include <hardware/gralloc.h>
+
+#include "DisplayHardware/DisplaySurface.h"
+#include "DisplayHardware/HWComposer.h"
+#ifdef USE_HWC2
+#include "DisplayHardware/HWC2.h"
+#endif
+#include "RenderEngine/RenderEngine.h"
+
+#include "clz.h"
+#include "DisplayDevice.h"
+#include "SurfaceFlinger.h"
+#include "Layer.h"
+
+// ----------------------------------------------------------------------------
+using namespace android;
+// ----------------------------------------------------------------------------
+
+#ifdef EGL_ANDROID_swap_rectangle
+static constexpr bool kEGLAndroidSwapRectangle = true;
+#else
+static constexpr bool kEGLAndroidSwapRectangle = false;
+#endif
+
+#if !defined(EGL_EGLEXT_PROTOTYPES) || !defined(EGL_ANDROID_swap_rectangle)
+// Dummy implementation in case it is missing.
+inline void eglSetSwapRectangleANDROID (EGLDisplay, EGLSurface, EGLint, EGLint, EGLint, EGLint) {
+}
+#endif
+
+/*
+ * Initialize the display to the specified values.
+ *
+ */
+
+uint32_t DisplayDevice::sPrimaryDisplayOrientation = 0;
+
+DisplayDevice::DisplayDevice(
+        const sp<SurfaceFlinger>& flinger,
+        DisplayType type,
+        int32_t hwcId,
+#ifndef USE_HWC2
+        int format,
+#endif
+        bool isSecure,
+        const wp<IBinder>& displayToken,
+        const sp<DisplaySurface>& displaySurface,
+        const sp<IGraphicBufferProducer>& producer,
+        EGLConfig config)
+    : lastCompositionHadVisibleLayers(false),
+      mFlinger(flinger),
+      mType(type),
+      mHwcDisplayId(hwcId),
+      mDisplayToken(displayToken),
+      mDisplaySurface(displaySurface),
+      mDisplay(EGL_NO_DISPLAY),
+      mSurface(EGL_NO_SURFACE),
+      mDisplayWidth(),
+      mDisplayHeight(),
+#ifndef USE_HWC2
+      mFormat(),
+#endif
+      mFlags(),
+      mPageFlipCount(),
+      mIsSecure(isSecure),
+      mLayerStack(NO_LAYER_STACK),
+      mOrientation(),
+      mPowerMode(HWC_POWER_MODE_OFF),
+      mActiveConfig(0)
+{
+    Surface* surface;
+    mNativeWindow = surface = new Surface(producer, false);
+    ANativeWindow* const window = mNativeWindow.get();
+    char property[PROPERTY_VALUE_MAX];
+
+    /*
+     * Create our display's surface
+     */
+
+    EGLSurface eglSurface;
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (config == EGL_NO_CONFIG) {
+#ifdef USE_HWC2
+        config = RenderEngine::chooseEglConfig(display, PIXEL_FORMAT_RGBA_8888);
+#else
+        config = RenderEngine::chooseEglConfig(display, format);
+#endif
+    }
+    eglSurface = eglCreateWindowSurface(display, config, window, NULL);
+    eglQuerySurface(display, eglSurface, EGL_WIDTH,  &mDisplayWidth);
+    eglQuerySurface(display, eglSurface, EGL_HEIGHT, &mDisplayHeight);
+
+    // Make sure that composition can never be stalled by a virtual display
+    // consumer that isn't processing buffers fast enough. We have to do this
+    // in two places:
+    // * Here, in case the display is composed entirely by HWC.
+    // * In makeCurrent(), using eglSwapInterval. Some EGL drivers set the
+    //   window's swap interval in eglMakeCurrent, so they'll override the
+    //   interval we set here.
+    if (mType >= DisplayDevice::DISPLAY_VIRTUAL)
+        window->setSwapInterval(window, 0);
+
+    mConfig = config;
+    mDisplay = display;
+    mSurface = eglSurface;
+#ifndef USE_HWC2
+    mFormat = format;
+#endif
+    mPageFlipCount = 0;
+    mViewport.makeInvalid();
+    mFrame.makeInvalid();
+
+    // virtual displays are always considered enabled
+    mPowerMode = (mType >= DisplayDevice::DISPLAY_VIRTUAL) ?
+                  HWC_POWER_MODE_NORMAL : HWC_POWER_MODE_OFF;
+
+    // Name the display.  The name will be replaced shortly if the display
+    // was created with createDisplay().
+    switch (mType) {
+        case DISPLAY_PRIMARY:
+            mDisplayName = "Built-in Screen";
+            break;
+        case DISPLAY_EXTERNAL:
+            mDisplayName = "HDMI Screen";
+            break;
+        default:
+            mDisplayName = "Virtual Screen";    // e.g. Overlay #n
+            break;
+    }
+
+    // we store the value as orientation:
+    // 90 -> 1, 180 -> 2, 270 -> 3
+    mHardwareRotation = property_get_int32("ro.sf.hwrotation", 0) / 90;
+
+    mPanelMountFlip = 0;
+    // 1: H-Flip, 2: V-Flip, 3: 180 (HV Flip)
+    property_get("ro.panel.mountflip", property, "0");
+    mPanelMountFlip = atoi(property);
+
+    // initialize the display orientation transform.
+    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+
+#ifdef NUM_FRAMEBUFFER_SURFACE_BUFFERS
+    surface->allocateBuffers();
+#endif
+}
+
+DisplayDevice::~DisplayDevice() {
+    if (mSurface != EGL_NO_SURFACE) {
+        eglDestroySurface(mDisplay, mSurface);
+        mSurface = EGL_NO_SURFACE;
+    }
+}
+
+void DisplayDevice::disconnect(HWComposer& hwc) {
+    if (mHwcDisplayId >= 0) {
+        hwc.disconnectDisplay(mHwcDisplayId);
+#ifndef USE_HWC2
+        if (mHwcDisplayId >= DISPLAY_VIRTUAL)
+            hwc.freeDisplayId(mHwcDisplayId);
+#endif
+        mHwcDisplayId = -1;
+    }
+}
+
+bool DisplayDevice::isValid() const {
+    return mFlinger != NULL;
+}
+
+int DisplayDevice::getWidth() const {
+    return mDisplayWidth;
+}
+
+int DisplayDevice::getHeight() const {
+    return mDisplayHeight;
+}
+
+#ifndef USE_HWC2
+PixelFormat DisplayDevice::getFormat() const {
+    return mFormat;
+}
+#endif
+
+EGLSurface DisplayDevice::getEGLSurface() const {
+    return mSurface;
+}
+
+void DisplayDevice::setDisplayName(const String8& displayName) {
+    if (!displayName.isEmpty()) {
+        // never override the name with an empty name
+        mDisplayName = displayName;
+    }
+}
+
+uint32_t DisplayDevice::getPageFlipCount() const {
+    return mPageFlipCount;
+}
+
+#ifndef USE_HWC2
+status_t DisplayDevice::compositionComplete() const {
+    return mDisplaySurface->compositionComplete();
+}
+#endif
+
+void DisplayDevice::flip(const Region& dirty) const
+{
+    mFlinger->getRenderEngine().checkErrors();
+
+    if (kEGLAndroidSwapRectangle) {
+        if (mFlags & SWAP_RECTANGLE) {
+            const Region newDirty(dirty.intersect(bounds()));
+            const Rect b(newDirty.getBounds());
+            eglSetSwapRectangleANDROID(mDisplay, mSurface,
+                    b.left, b.top, b.width(), b.height());
+        }
+    }
+
+    mPageFlipCount++;
+}
+
+status_t DisplayDevice::beginFrame(bool mustRecompose) const {
+    return mDisplaySurface->beginFrame(mustRecompose);
+}
+
+#ifdef USE_HWC2
+status_t DisplayDevice::prepareFrame(HWComposer& hwc) {
+    status_t error = hwc.prepare(*this);
+    if (error != NO_ERROR) {
+        return error;
+    }
+
+    DisplaySurface::CompositionType compositionType;
+    bool hasClient = hwc.hasClientComposition(mHwcDisplayId);
+    bool hasDevice = hwc.hasDeviceComposition(mHwcDisplayId);
+    if (hasClient && hasDevice) {
+        compositionType = DisplaySurface::COMPOSITION_MIXED;
+    } else if (hasClient) {
+        compositionType = DisplaySurface::COMPOSITION_GLES;
+    } else if (hasDevice) {
+        compositionType = DisplaySurface::COMPOSITION_HWC;
+    } else {
+        // Nothing to do -- when turning the screen off we get a frame like
+        // this. Call it a HWC frame since we won't be doing any GLES work but
+        // will do a prepare/set cycle.
+        compositionType = DisplaySurface::COMPOSITION_HWC;
+    }
+    return mDisplaySurface->prepareFrame(compositionType);
+}
+#else
+status_t DisplayDevice::prepareFrame(const HWComposer& hwc) const {
+    DisplaySurface::CompositionType compositionType;
+    bool haveGles = hwc.hasGlesComposition(mHwcDisplayId);
+    bool haveHwc = hwc.hasHwcComposition(mHwcDisplayId);
+    if (haveGles && haveHwc) {
+        compositionType = DisplaySurface::COMPOSITION_MIXED;
+    } else if (haveGles) {
+        compositionType = DisplaySurface::COMPOSITION_GLES;
+    } else if (haveHwc) {
+        compositionType = DisplaySurface::COMPOSITION_HWC;
+    } else {
+        // Nothing to do -- when turning the screen off we get a frame like
+        // this. Call it a HWC frame since we won't be doing any GLES work but
+        // will do a prepare/set cycle.
+        compositionType = DisplaySurface::COMPOSITION_HWC;
+    }
+    return mDisplaySurface->prepareFrame(compositionType);
+}
+#endif
+
+void DisplayDevice::swapBuffers(HWComposer& hwc) const {
+#ifdef USE_HWC2
+    if (hwc.hasClientComposition(mHwcDisplayId)) {
+#else
+    // We need to call eglSwapBuffers() if:
+    //  (1) we don't have a hardware composer, or
+    //  (2) we did GLES composition this frame, and either
+    //    (a) we have framebuffer target support (not present on legacy
+    //        devices, where HWComposer::commit() handles things); or
+    //    (b) this is a virtual display
+    if (hwc.initCheck() != NO_ERROR ||
+            (hwc.hasGlesComposition(mHwcDisplayId) &&
+             (hwc.supportsFramebufferTarget() || mType >= DISPLAY_VIRTUAL))) {
+#endif
+        EGLBoolean success = eglSwapBuffers(mDisplay, mSurface);
+        if (!success) {
+            EGLint error = eglGetError();
+            if (error == EGL_CONTEXT_LOST ||
+                    mType == DisplayDevice::DISPLAY_PRIMARY) {
+                LOG_ALWAYS_FATAL("eglSwapBuffers(%p, %p) failed with 0x%08x",
+                        mDisplay, mSurface, error);
+            } else {
+                ALOGE("eglSwapBuffers(%p, %p) failed with 0x%08x",
+                        mDisplay, mSurface, error);
+            }
+        }
+    }
+
+    status_t result = mDisplaySurface->advanceFrame();
+    if (result != NO_ERROR) {
+        ALOGE("[%s] failed pushing new frame to HWC: %d",
+                mDisplayName.string(), result);
+    }
+}
+
+#ifdef USE_HWC2
+void DisplayDevice::onSwapBuffersCompleted() const {
+    mDisplaySurface->onFrameCommitted();
+}
+#else
+void DisplayDevice::onSwapBuffersCompleted(HWComposer& hwc) const {
+    if (hwc.initCheck() == NO_ERROR) {
+        mDisplaySurface->onFrameCommitted();
+    }
+}
+#endif
+
+uint32_t DisplayDevice::getFlags() const
+{
+    return mFlags;
+}
+
+EGLBoolean DisplayDevice::makeCurrent(EGLDisplay dpy, EGLContext ctx) const {
+    EGLBoolean result = EGL_TRUE;
+    EGLSurface sur = eglGetCurrentSurface(EGL_DRAW);
+    if (sur != mSurface) {
+        result = eglMakeCurrent(dpy, mSurface, mSurface, ctx);
+        if (result == EGL_TRUE) {
+            if (mType >= DisplayDevice::DISPLAY_VIRTUAL)
+                eglSwapInterval(dpy, 0);
+        }
+    }
+    setViewportAndProjection();
+    return result;
+}
+
+void DisplayDevice::setViewportAndProjection() const {
+    size_t w = mDisplayWidth;
+    size_t h = mDisplayHeight;
+    Rect sourceCrop(0, 0, w, h);
+    mFlinger->getRenderEngine().setViewportAndProjection(w, h, sourceCrop, h,
+        false, Transform::ROT_0);
+}
+
+const sp<Fence>& DisplayDevice::getClientTargetAcquireFence() const {
+    return mDisplaySurface->getClientTargetAcquireFence();
+}
+
+// ----------------------------------------------------------------------------
+
+void DisplayDevice::setVisibleLayersSortedByZ(const Vector< sp<Layer> >& layers) {
+    mVisibleLayersSortedByZ = layers;
+}
+
+const Vector< sp<Layer> >& DisplayDevice::getVisibleLayersSortedByZ() const {
+    return mVisibleLayersSortedByZ;
+}
+
+Region DisplayDevice::getDirtyRegion(bool repaintEverything) const {
+    Region dirty;
+    if (repaintEverything) {
+        dirty.set(getBounds());
+    } else {
+        const Transform& planeTransform(mGlobalTransform);
+        dirty = planeTransform.transform(this->dirtyRegion);
+        dirty.andSelf(getBounds());
+    }
+    return dirty;
+}
+
+// ----------------------------------------------------------------------------
+void DisplayDevice::setPowerMode(int mode) {
+    mPowerMode = mode;
+}
+
+int DisplayDevice::getPowerMode()  const {
+    return mPowerMode;
+}
+
+bool DisplayDevice::isDisplayOn() const {
+    return (mPowerMode != HWC_POWER_MODE_OFF);
+}
+
+// ----------------------------------------------------------------------------
+void DisplayDevice::setActiveConfig(int mode) {
+    mActiveConfig = mode;
+}
+
+int DisplayDevice::getActiveConfig()  const {
+    return mActiveConfig;
+}
+
+// ----------------------------------------------------------------------------
+#ifdef USE_HWC2
+void DisplayDevice::setActiveColorMode(android_color_mode_t mode) {
+    mActiveColorMode = mode;
+}
+
+android_color_mode_t DisplayDevice::getActiveColorMode() const {
+    return mActiveColorMode;
+}
+#endif
+
+// ----------------------------------------------------------------------------
+
+void DisplayDevice::setLayerStack(uint32_t stack) {
+    mLayerStack = stack;
+    dirtyRegion.set(bounds());
+}
+
+// ----------------------------------------------------------------------------
+
+uint32_t DisplayDevice::getOrientationTransform() const {
+    uint32_t transform = 0;
+    switch (mOrientation) {
+        case DisplayState::eOrientationDefault:
+            transform = Transform::ROT_0;
+            break;
+        case DisplayState::eOrientation90:
+            transform = Transform::ROT_90;
+            break;
+        case DisplayState::eOrientation180:
+            transform = Transform::ROT_180;
+            break;
+        case DisplayState::eOrientation270:
+            transform = Transform::ROT_270;
+            break;
+    }
+    return transform;
+}
+
+status_t DisplayDevice::orientationToTransfrom(
+        int orientation, int w, int h, Transform* tr)
+{
+    uint32_t flags = 0;
+
+    if (mHardwareRotation && mType == DISPLAY_PRIMARY) {
+        orientation += mHardwareRotation;
+        orientation %= 4;
+    }
+
+    switch (orientation) {
+    case DisplayState::eOrientationDefault:
+        flags = Transform::ROT_0;
+        break;
+    case DisplayState::eOrientation90:
+        flags = Transform::ROT_90;
+        break;
+    case DisplayState::eOrientation180:
+        flags = Transform::ROT_180;
+        break;
+    case DisplayState::eOrientation270:
+        flags = Transform::ROT_270;
+        break;
+    default:
+        return BAD_VALUE;
+    }
+
+    if (DISPLAY_PRIMARY == mHwcDisplayId) {
+        flags = flags ^ getPanelMountFlip();
+    }
+
+    tr->set(flags, w, h);
+    return NO_ERROR;
+}
+
+void DisplayDevice::setDisplaySize(const int newWidth, const int newHeight) {
+    dirtyRegion.set(getBounds());
+
+    if (mSurface != EGL_NO_SURFACE) {
+        eglDestroySurface(mDisplay, mSurface);
+        mSurface = EGL_NO_SURFACE;
+    }
+
+    mDisplaySurface->resizeBuffers(newWidth, newHeight);
+
+    ANativeWindow* const window = mNativeWindow.get();
+    mSurface = eglCreateWindowSurface(mDisplay, mConfig, window, NULL);
+    eglQuerySurface(mDisplay, mSurface, EGL_WIDTH,  &mDisplayWidth);
+    eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mDisplayHeight);
+
+    LOG_FATAL_IF(mDisplayWidth != newWidth,
+                "Unable to set new width to %d", newWidth);
+    LOG_FATAL_IF(mDisplayHeight != newHeight,
+                "Unable to set new height to %d", newHeight);
+}
+
+void DisplayDevice::setProjection(int orientation,
+        const Rect& newViewport, const Rect& newFrame) {
+    Rect viewport(newViewport);
+    Rect frame(newFrame);
+
+    const int w = mDisplayWidth;
+    const int h = mDisplayHeight;
+
+    Transform R;
+    DisplayDevice::orientationToTransfrom(orientation, w, h, &R);
+
+    if (!frame.isValid()) {
+        // the destination frame can be invalid if it has never been set,
+        // in that case we assume the whole display frame.
+        if (mHardwareRotation == 1 || mHardwareRotation == 3) {
+            frame = Rect(h, w);
+        } else {
+            frame = Rect(w, h);
+        }
+    }
+
+    if (viewport.isEmpty()) {
+        // viewport can be invalid if it has never been set, in that case
+        // we assume the whole display size.
+        // it's also invalid to have an empty viewport, so we handle that
+        // case in the same way.
+        viewport = Rect(w, h);
+        if (R.getOrientation() & Transform::ROT_90) {
+            // viewport is always specified in the logical orientation
+            // of the display (ie: post-rotation).
+            swap(viewport.right, viewport.bottom);
+        }
+    }
+
+    dirtyRegion.set(getBounds());
+
+    Transform TL, TP, S;
+    float src_width  = viewport.width();
+    float src_height = viewport.height();
+    float dst_width  = frame.width();
+    float dst_height = frame.height();
+    if (src_width != dst_width || src_height != dst_height) {
+        float sx = dst_width  / src_width;
+        float sy = dst_height / src_height;
+        S.set(sx, 0, 0, sy);
+    }
+
+    float src_x = viewport.left;
+    float src_y = viewport.top;
+    float dst_x = frame.left;
+    float dst_y = frame.top;
+    TL.set(-src_x, -src_y);
+    TP.set(dst_x, dst_y);
+
+    // The viewport and frame are both in the logical orientation.
+    // Apply the logical translation, scale to physical size, apply the
+    // physical translation and finally rotate to the physical orientation.
+    mGlobalTransform = R * TP * S * TL;
+
+    const uint8_t type = mGlobalTransform.getType();
+    mNeedsFiltering = (!mGlobalTransform.preserveRects() ||
+            (type >= Transform::SCALE));
+
+    mScissor = mGlobalTransform.transform(viewport);
+    if (mScissor.isEmpty()) {
+        mScissor = getBounds();
+    }
+
+    mOrientation = orientation;
+    if (mType == DisplayType::DISPLAY_PRIMARY) {
+        uint32_t transform = 0;
+        switch (mOrientation) {
+            case DisplayState::eOrientationDefault:
+                transform = Transform::ROT_0;
+                break;
+            case DisplayState::eOrientation90:
+                transform = Transform::ROT_90;
+                break;
+            case DisplayState::eOrientation180:
+                transform = Transform::ROT_180;
+                break;
+            case DisplayState::eOrientation270:
+                transform = Transform::ROT_270;
+                break;
+        }
+        sPrimaryDisplayOrientation = transform;
+    }
+    mViewport = viewport;
+    mFrame = frame;
+}
+
+uint32_t DisplayDevice::getPrimaryDisplayOrientationTransform() {
+    return sPrimaryDisplayOrientation;
+}
+
+void DisplayDevice::dump(String8& result) const {
+    const Transform& tr(mGlobalTransform);
+    result.appendFormat(
+        "+ DisplayDevice: %s\n"
+        "   type=%x, hwcId=%d, layerStack=%u, (%4dx%4d), ANativeWindow=%p, orient=%2d (type=%08x), "
+        "flips=%u, isSecure=%d, powerMode=%d, activeConfig=%d, numLayers=%zu\n"
+        "   v:[%d,%d,%d,%d], f:[%d,%d,%d,%d], s:[%d,%d,%d,%d],"
+        "transform:[[%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f]]\n",
+        mDisplayName.string(), mType, mHwcDisplayId,
+        mLayerStack, mDisplayWidth, mDisplayHeight, mNativeWindow.get(),
+        mOrientation, tr.getType(), getPageFlipCount(),
+        mIsSecure, mPowerMode, mActiveConfig,
+        mVisibleLayersSortedByZ.size(),
+        mViewport.left, mViewport.top, mViewport.right, mViewport.bottom,
+        mFrame.left, mFrame.top, mFrame.right, mFrame.bottom,
+        mScissor.left, mScissor.top, mScissor.right, mScissor.bottom,
+        tr[0][0], tr[1][0], tr[2][0],
+        tr[0][1], tr[1][1], tr[2][1],
+        tr[0][2], tr[1][2], tr[2][2]);
+
+    String8 surfaceDump;
+    mDisplaySurface->dumpAsString(surfaceDump);
+    result.append(surfaceDump);
+}
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index bd4b04b..9c0f49a 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -131,6 +131,7 @@ public:
     uint32_t                getOrientationTransform() const;
     static uint32_t         getPrimaryDisplayOrientationTransform();
     const Transform&        getTransform() const { return mGlobalTransform; }
+    const Transform&        getOriginalTransform() const { return mOriginalTransform; }
     const Rect              getViewport() const { return mViewport; }
     const Rect              getFrame() const { return mFrame; }
     const Rect&             getScissor() const { return mScissor; }
@@ -246,6 +247,7 @@ private:
     status_t orientationToTransfrom(int orientation,
             int w, int h, Transform* tr);
 
+    void setDisplayDevice();
     uint32_t mLayerStack;
     int mOrientation;
     static uint32_t sPrimaryDisplayOrientation;
@@ -256,6 +258,8 @@ private:
     // pre-computed scissor to apply to the display
     Rect mScissor;
     Transform mGlobalTransform;
+    Transform mOriginalTransform;
+    Transform mDisplayTransform;
     bool mNeedsFiltering;
     // Current power mode
     int mPowerMode;
diff --git a/services/surfaceflinger/DisplayHardware/DisplaySurface.h b/services/surfaceflinger/DisplayHardware/DisplaySurface.h
index d801bb3..4444be7 100644
--- a/services/surfaceflinger/DisplayHardware/DisplaySurface.h
+++ b/services/surfaceflinger/DisplayHardware/DisplaySurface.h
@@ -78,8 +78,16 @@ public:
 
     virtual const sp<Fence>& getClientTargetAcquireFence() const = 0;
 
+    inline int getFBFormat() const
+    {
+        return mFBFormat;
+    }
+
 protected:
-    DisplaySurface() {}
+    int mFBFormat;
+    DisplaySurface()
+    : mFBFormat(HAL_PIXEL_FORMAT_RGBA_8888)
+    {}
     virtual ~DisplaySurface() {}
 };
 
diff --git a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
index 1cef4fd..5dc22f7 100644
--- a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
@@ -90,6 +90,7 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc, int32_t dispId,
     // with GLES. If the consumer needs CPU access, use the default format
     // set by the consumer. Otherwise allow gralloc to decide the format based
     // on usage bits.
+#if 0
     int sinkUsage;
     sink->query(NATIVE_WINDOW_CONSUMER_USAGE_BITS, &sinkUsage);
     if (sinkUsage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
@@ -99,7 +100,22 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc, int32_t dispId,
     } else {
         mDefaultOutputFormat = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
     }
+#else
+    int sinkFormat;
+    sink->query(NATIVE_WINDOW_FORMAT, &sinkFormat);
+    mDefaultOutputFormat = sinkFormat;
+#endif
     mOutputFormat = mDefaultOutputFormat;
+    if (sForceHwcCopy)
+    {
+        int scratchFormat;
+        bqProducer->query(NATIVE_WINDOW_FORMAT, &scratchFormat);
+        mFBFormat = scratchFormat;
+    }
+    else
+    {
+        mFBFormat = mDefaultOutputFormat;
+    }
 
     ConsumerBase::mName = String8::format("VDS: %s", mDisplayName.string());
     mConsumer->setConsumerName(ConsumerBase::mName);
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 9114fdc..1163bb0 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -302,6 +302,12 @@ const String8& Layer::getName() const {
 status_t Layer::setBuffers( uint32_t w, uint32_t h,
                             PixelFormat format, uint32_t flags)
 {
+    uint32_t usage = getEffectiveUsage(0);
+    if (flags & ISurfaceComposerClient::eFXSurfaceHWAcc)
+    {
+        usage |= GraphicBuffer::USAGE_HW_TILE_ALIGN;
+    }
+
     uint32_t const maxSurfaceDims = min(
             mFlinger->getMaxTextureSize(), mFlinger->getMaxViewportDims());
 
@@ -320,7 +326,7 @@ status_t Layer::setBuffers( uint32_t w, uint32_t h,
 
     mSurfaceFlingerConsumer->setDefaultBufferSize(w, h);
     mSurfaceFlingerConsumer->setDefaultBufferFormat(format);
-    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
+    mSurfaceFlingerConsumer->setConsumerUsageBits(usage);
 
     return NO_ERROR;
 }
@@ -805,7 +811,7 @@ void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
     // after HWComposer::commit() -- every frame.
     // Apply this display's projection's viewport to the visible region
     // before giving it to the HWC HAL.
-    const Transform& tr = hw->getTransform();
+    const Transform& tr = hw->getOriginalTransform();
     Region visible = tr.transform(visibleRegion.intersect(hw->getViewport()));
     layer.setVisibleRegionScreen(visible);
     layer.setSurfaceDamage(surfaceDamageRegion);
@@ -1300,7 +1306,21 @@ void Layer::computeGeometry(const sp<const DisplayDevice>& hw, Mesh& mesh,
 {
     const Layer::State& s(getDrawingState());
     const Transform tr(hw->getTransform());
-    const uint32_t hw_h = hw->getHeight();
+    uint32_t hw_h = hw->getHeight();
+	char property[PROPERTY_VALUE_MAX];
+    if ((hw->getDisplayType() == DisplayDevice::DISPLAY_PRIMARY)
+        && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+        //displayOrientation
+        switch (atoi(property)) {
+            case 90:
+            case 270:
+                hw_h = hw->getWidth();
+                break;
+            default:
+                break;
+        }
+    }
+
     Rect win(s.active.w, s.active.h);
     if (!s.crop.isEmpty()) {
         win.intersect(s.crop, &win);
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index d71baf9..b7a2678 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -506,6 +506,7 @@ void SurfaceFlinger::init() {
     mHwc = new HWComposer(this);
     mHwc->setEventHandler(static_cast<HWComposer::EventHandler*>(this));
 
+    uint32_t builtInDisplayNum = DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES;
     Mutex::Autolock _l(mStateLock);
 
     // retrieve the EGL context that was selected/created
@@ -643,6 +644,20 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
         else {
             info.w = hwConfig->getWidth();
             info.h = hwConfig->getHeight();
+            char property[PROPERTY_VALUE_MAX];
+            if ((type == DisplayDevice::DISPLAY_PRIMARY)
+                && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+                //displayOrientation
+                switch (atoi(property)) {
+                    case 90:
+                    case 270:
+                    info.w = hwConfig.height;
+                    info.h = hwConfig.width;
+                    break;
+                    default:
+                    break;
+                }
+            }
             info.xdpi = xdpi;
             info.ydpi = ydpi;
         }
@@ -1275,7 +1290,7 @@ void SurfaceFlinger::rebuildLayerStacks() {
             Region dirtyRegion;
             Vector<sp<Layer>> layersSortedByZ;
             const sp<DisplayDevice>& displayDevice(mDisplays[dpy]);
-            const Transform& tr(displayDevice->getTransform());
+            const Transform& tr(displayDevice->getOriginalTransform());
             const Rect bounds(displayDevice->getBounds());
             if (displayDevice->isDisplayOn()) {
                 SurfaceFlinger::computeVisibleRegions(dpy, layers,
@@ -2176,7 +2191,7 @@ bool SurfaceFlinger::doComposeSurfaces(
      */
 
     ALOGV("Rendering client layers");
-    const Transform& displayTransform = displayDevice->getTransform();
+    const Transform& displayTransform = displayDevice->getOriginalTransform();
     if (hwcId >= 0) {
         // we're using h/w composer
         bool firstLayer = true;
